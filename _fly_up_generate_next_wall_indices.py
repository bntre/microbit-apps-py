# 'Fly up' game helper script to generate walls by complexity
#
# The result of this script:
#   for each wall [0..30]:
#    for each complexity [0..9]:
#     next wall indices


import random


def wall_index_to_tuple(i):
    t = ()
    for _ in range(5):
        t = (i & 1,) + t
        i >>= 1
    return t

def wall_tuple_to_string(t):
    """
    (0, 1, 0, 0, 1) -> " #  #"
    """
    return "".join(b and '#' or ' ' for b in t)


def get_wall_tuple_props(t):
    # hard (to fly through)
    hard = sum(t)
    # left/right side (is open)
    side = 0
    c = 0  # count of zeros
    for b,i in zip(t, (-2,-1,0,1,2)):
        if b == 0:
            side += i
            c += 1
    if c:
        side = side * 12 // c  # [-24..24]
    return hard, side


def iter_walls():
    for index in range(2**5 - 1):  # except solid wall (#####)
        Tuple = wall_index_to_tuple(index)
        hard, side = get_wall_tuple_props(Tuple)
        nexts = []
        yield (index, Tuple, hard, side, nexts)


def generate_wall_nexts():

    walls = list(iter_walls())  # [(index, tuple, hard, side, nexts)]
    
    for (i0, t0, h0, s0, nexts0) in walls:
        
        # get nexts
        for (i1, t1, h1, s1, _) in walls:
            c = h1*12 + abs(s0-s1)  # max value: 4*12 + 48 = 96
            c //= 10  # c: [0..9]
            nexts0.append((c, i1))

        nexts0.sort(key = lambda n: n[0])  # sort nexts by complexity


        print("%d %s |%s| %s" % (i0, t0, wall_tuple_to_string(t0), (h0, s0)))
        for c,i1 in nexts0:
            _, t1, h1, s1, _ = walls[i1]
            print("  %d |%s| %s" % (c, wall_tuple_to_string(t1), (h1, s1)))
    
    
    # print result
    
    def format_indices(nn):
        return repr(tuple(nn)).replace(" ","")
    
    print("_wall_nexts = (")
    for (_, _, _, _, nexts) in walls:
        nnn = [[] for i in range(10)]  # next wall indices [0..30] for each complexity [0..9]
        for (c, i) in nexts:
            nnn[c].append(i)
        print(" (%s)," % ", ".join(format_indices(nn) for nn in nnn))
    print(")")


# generate_wall_nexts output:
_wall_nexts = (
 ((0,), (1,2,4,8,16), (6,9,10,12,17,18), (3,5,14,20,21,24), (11,13,19,22,25,26,27), (7,28), (23,29), (15,30), (), ()),
 ((0,), (1,2,4), (5,6,8,9,16), (3,10,12,13,17,18,19,20), (7,11,14,21,22,24,25), (23,26,27), (15,28,29), (30,), (), ()),
 ((0,), (1,2,4,8), (5,6,9,10,16,17), (3,12,13,14,18,19,20,21,24), (11,22,25), (7,23,26,27,28), (15,29), (30,), (), ()),
 ((), (0,1), (2,3,4,5,8), (6,9,10,11,16,17), (7,12,13,14,18,19,20,21,23,24), (22,25), (15,26,27,28), (29,), (30,), ()),
 ((0,), (1,2,4,8,16), (6,9,10,12,17,18), (3,5,14,20,21,24), (11,13,19,22,25,26,27), (7,28), (23,29), (15,30), (), ()),
 ((0,), (1,2), (3,4,5,6,8,9,16), (10,12,13,17,18,19), (7,11,14,20,21,24), (22,23,25,26,27), (15,28,29), (), (30,), ()),
 ((0,), (1,2,4,8), (5,6,9,10,16,17), (3,12,13,18,19,20), (11,14,21,22,24,25), (7,23,26,27,28), (15,29), (30,), (), ()),
 ((), (0,), (1,2), (3,4,5,6,7,8,9,16), (10,11,12,13,17,18,19), (14,15,20,21,23,24), (22,25,26,27), (28,29), (), (30,)),
 ((0,), (2,4,8,16), (1,10,12,17,18,20), (3,5,6,9,14,21,22,24,25), (13,19,26), (7,11,27,28,29), (23,30), (15,), (), ()),
 ((0,), (1,2,4,8), (5,6,9,10,16,17), (3,12,13,18,19,20), (11,14,21,22,24,25), (7,23,26,27,28), (15,29), (30,), (), ()),
 ((0,), (1,2,4,8,16), (6,9,10,12,17,18), (3,5,14,20,21,24), (11,13,19,22,25,26,27), (7,28), (23,29), (15,30), (), ()),
 ((), (0,1), (2,3,4,5,8), (6,9,10,11,16,17), (7,12,13,14,18,19,20,21,23,24), (22,25), (15,26,27,28), (29,), (30,), ()),
 ((0,), (2,4,8,16), (1,10,12,17,18,20), (5,6,9,22,24,25), (3,13,14,19,21,26), (7,11,27,28,29), (23,30), (15,), (), ()),
 ((0,), (1,2,4), (5,6,8,9,16), (3,10,12,13,17,18,19,20), (7,11,14,21,22,24,25), (23,26,27), (15,28,29), (30,), (), ()),
 ((0,), (1,2,4,8,16), (6,9,10,12,17,18), (3,5,14,20,21,24), (11,13,19,22,25,26,27), (7,28), (23,29), (15,30), (), ()),
 ((), (), (0,), (1,2,3,4,8), (5,6,7,9,10,11,15,16,17), (12,13,18,19,20), (14,21,22,23,24,25), (26,27,28), (29,), (30,)),
 ((0,), (4,8,16), (1,2,12,18,20), (5,6,9,10,17,22,24,25), (3,13,14,19,21,26,28), (11,27,29), (7,23,30), (15,), (), ()),
 ((0,), (1,2,4,8,16), (6,9,10,12,17,18), (3,5,14,20,21,24), (11,13,19,22,25,26,27), (7,28), (23,29), (15,30), (), ()),
 ((0,), (2,4,8,16), (1,10,12,17,18,20), (5,6,9,22,24,25), (3,13,14,19,21,26), (7,11,27,28,29), (23,30), (15,), (), ()),
 ((0,), (1,2,4), (5,6,8,9,16), (3,10,12,13,17,18,19,20), (7,11,14,21,22,24,25), (23,26,27), (15,28,29), (30,), (), ()),
 ((0,), (8,16), (1,2,4,12,18,20,24), (6,9,10,17,22,25), (3,5,14,21,26,28), (11,13,19,27,29), (7,23,30), (), (15,), ()),
 ((0,), (1,2,4,8,16), (6,9,10,12,17,18), (3,5,14,20,21,24), (11,13,19,22,25,26,27), (7,28), (23,29), (15,30), (), ()),
 ((0,), (4,8,16), (1,2,12,18,20), (5,6,9,10,17,22,24,25), (3,13,14,19,21,26,28), (11,27,29), (7,23,30), (15,), (), ()),
 ((), (0,1), (2,3,4,5,8), (6,9,10,11,16,17), (7,12,13,14,18,19,20,21,23,24), (22,25), (15,26,27,28), (29,), (30,), ()),
 ((), (0,16), (2,4,8,20,24), (1,10,12,17,18,26), (3,5,6,9,14,21,22,25,28,29), (13,19), (7,11,27,30), (23,), (15,), ()),
 ((0,), (4,8,16), (1,2,12,18,20), (5,6,9,10,17,22,24,25), (3,13,14,19,21,26,28), (11,27,29), (7,23,30), (15,), (), ()),
 ((), (0,16), (2,4,8,20,24), (1,10,12,17,18,26), (3,5,6,9,14,21,22,25,28,29), (13,19), (7,11,27,30), (23,), (15,), ()),
 ((0,), (1,2,4,8,16), (6,9,10,12,17,18), (3,5,14,20,21,24), (11,13,19,22,25,26,27), (7,28), (23,29), (15,30), (), ()),
 ((), (0,), (8,16), (1,2,4,12,18,20,24,28), (6,9,10,17,22,25,26), (3,5,14,21,29,30), (11,13,19,27), (7,23), (), (15,)),
 ((), (0,16), (2,4,8,20,24), (1,10,12,17,18,26), (3,5,6,9,14,21,22,25,28,29), (13,19), (7,11,27,30), (23,), (15,), ()),
 ((), (), (0,), (2,4,8,16,24), (1,10,12,17,18,20,26,28,30), (5,6,9,22,25), (3,13,14,19,21,29), (7,11,27), (23,), (15,)),
)


def get_random_wall(prevWallIndex, complexity):
    variants = []  # list of pairs (wall index, complexity)
    for c,k in zip(range(complexity-2, complexity+3), (1,2,5,2,1)):
        if 0 <= c and c < 10:
            variants += [(i,c) for i in _wall_nexts[prevWallIndex][c]] * k
    print(prevWallIndex, complexity, "variants", variants)
    return random.choice(variants)


def print_level(level):
    """level is list of pairs (y, wall index)"""
    lines = []
    lastY = 0
    for y,i in level:
        lines += ["    |     |"] * (y - lastY - 1)
        w = wall_tuple_to_string(wall_index_to_tuple(i))
        lines.append("%03d |%s|" % (y, w))
        lastY = y
    for line in lines[::-1]:
        print(line)


def generate_level():

    level = []  # [(y, wall index)]
    
    levelLength = 200
    
    lastY = 0
    lastWallIndex = 0
    
    while lastY < levelLength:
        
        complexity = lastY * 10 // levelLength
        #complexity = 9
        
        newWallIndex, c = get_random_wall(lastWallIndex, complexity)
        newY = lastY + 4 + (c - complexity)  # increase distance if found complexity is higher than nominal one
        level.append((newY, newWallIndex))
        
        lastWallIndex = newWallIndex
        lastY = newY
        
        #if lastY > 30: break

    print_level(level)



def main():
    generate_wall_nexts()
    #generate_level()


main()
